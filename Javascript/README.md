# Modern Javascript Deep Dive 

## Table of Contents

1. [역사](#역사)
1. [ECMAScript](#ECMAScript)
1. [특징](#특징)
1. [변수](#변수)
1. [부록](#부록)

## 역사

- (1995) 넷스케이프 커뮤니케이션즈, 웹페이지의 보조적인 기능을 수행하기 위한 프로그래밍 언어 JavaScript 개발
        - 웹 서버에서 로직 실행 후, HTML, CSS를 브라우저로 전달 -> 브라우저가 렌더링

- (1996) 마이크로소프트, JavaScript 파생 언어 JScript 출시
- 서로 자사 브라우저의 시장 점유율을 높이기 위해 자사 브라우저에서만 동작하는 기능 추가
- 크로스 브라우징 이슈 발생 -> 브라우저에 따라 웹페이지가 정상적으로 동작하지 않음
- (1996) 넷스케이프 커뮤니케이션즈, JavaScript의 파편화 방지와 표준화의 중요성을 느끼고 ECMA 인터내셔널에 JavaScript 표준화 요청
- (1997) 상표권 문제로 이름 변경 & ECMAScript 1 specification 완성
- (1998) ES 2 : ISO/IEC 16262 국제 표준과 동일한 규격을 적용
- (1999) ES 3 : 정규표현식, try...catch 등
- XMLHTTPRequest (Ajax) 등장 -> Client Side Rendering 가능
- jQuery 등장 : Document Object Model을 더욱 쉽게 제어, 크로스 브라우징 이슈 어느 정도 해결
- V8 자바스크립트 엔진 등장 : 더 빠른 성능 -> 과거 서버에서 수행되던 로직이 대거 클라이언트(브라우저)로 이동
- Node.js 등장 : 요청 처리 성능 개선 -> 서버 사이드 애플리케이션 개발 가능

- (2009) ES 5 : HTML5와 함께 출현한 표준안, JSON, strict mode 등
- (2015) ES 6 : let/const 키워드, 화살표 함수, 클래스, 모듈, 디스트럭처링 할당, rest 파라미터 등
- ...
- 현재 : 모든 브라우저의 표준 프로그래밍 언어

## ECMAScript

- ECMAScript : JS 표준사양 (ECMA-262), 프로그래밍 언어의 핵심 문법을 규정함
- 각 브라우저 제조사는 ECMAScript 사양을 준수해서 브라우저에 내장되는 JS 엔진을 구현한다.
- JS는 일반적으로 프로그래밍 언어로서 코어를 이루는 ECMAScript + "브라우저"가 별도 지원하는 클라이언트 사이드 Web API (DOM, BOM, XMLHTTPRequest, SVG, Web Storage,...) 등을 아우르는 개념
- 클라이언트 사이드 Web API는 W3C (World Wide Web Consortium)에서 관리
- web API ()https://developer.mozilla.org/ko/docs/Web/API

<br/>

## 특징

- 명령형, 함수형, 프로토타입 기반 객체지향 프로그래밍을 지원하는 멀티 패러다임 프로그래밍 언어
- HTML, CSS와 함께 웹을 구성하는 요소중 하나로, 웹 브라우저에서 동작하는 유일한 프로그래밍 언어
- 개발자가 별도의 컴파일 작업을 수행하지 않는 인터프리터 언어
- 대부분의 모던 JS 엔진은 인터프리터+컴파일러 장점을 결합해 (일부 소스코드를 컴파일하고 실행)비교적 처리 속도가 느린 인터프리터의 단점을 해결
- 이를 통해 인터프리터 언어 장점인 동적 기능 지원을 살리고 실행속도가 느리다는 단점 극복

## 변수

- 변수 : 하나의 값을 저장하기 위해 확보된 메모리 공간 자체, 프로그래밍 언어에서 값을 저장하고 참조하는 매커니즘. 값의 위치를 가리킴
  - 변수는 컴파일러/인터프리터에 의해 메모리 공간의 주소로 치환되어 실행된다.
  - 이렇게 메모리 공간에 저장된 값을 식별할 수 있는 고유한 이름과 값을 각각 변수 이름(식별자)/ 변수값이라 한다.
  - 변수에 값을 저장하는 것을 할당, 값을 읽어들이는 것을 참조라 한다.
  - 변수 이름을 통해 참조를 요청하면 JS엔진은 변수 이름과 매핑된 메모리주소를 통해 메모리공간에 접근, 값을 반환한다.
  
- 컴퓨터 (연산)CPU / (기억)메모리
- 메모리 : 데이터를 저장할 수 있는 memory cell의 집합체. 컴퓨터는 메모리 셀의 크기 (1 byte, 8bit) 단위로 데이터를 저장하거나 읽음
- 각 셀은 고유의 memory address (0~16진법)를 가지며, 메모리 공간의 위치를 나타낸다.
- 컴퓨터는 모든 데이터를 2진수로 처리해서, 메모리에 저장되는 데이터는 모두 2진수로 저장된다.
- 예를 들어, 값은 메모리 상의 임의의 위치 (메모리 주소)에 저장된 후, CPU가 이 값을 읽어서 연산을 수행 -> 연산결과도 메모리 주소에 저장됨
- 연산된 값을 사용하려면 메모리 공간에 접근해야 하는데 직접 주소를 통해 공간에 접근하는 것은 치명적인 오류 발생 가능
- 또한, 값이 저장될 메모리주소는 '코드가 실행될 때' 메모리의 상황에 따라 임의로 결정됨 -> 코드실행될 때마다 메모리 주소 변경됨 또한, 코드 실행 전까지는 값이 저장된 메모리 주소를 알 수 없음
- 값을 재사용하기 위해 변수라는 매커니즘 사용
- 식별자 : 어떤 "값"(변수, 함수, 클래스 등)을 구별해서 식별할 수 있는 고유한 이름 (메모리 주소에 이름 붙인 것)
  - 식별자는 어떤 값이 저장되어 있는 "메모리 주소"를 기억해야 한다.
  - 즉, 식별자는 메모리 주소와 매핑관계를 맺으며, 이 매핑 정보도 메모리에 저장되어야 한다.
  - 변수, 함수, 클래스 등의 이름은 모두 식별자. 모두 네이밍 규칙을 준수해야 하며, declaration에 의해 JS엔진에 식별자의 존재를 알린다.

- 
- 


## (부록)
- 인터프리터 : 소스코드를 즉시 실행
- 컴파일러 : 빠르게 동작하는 머신 코드를 생성, 최적화 -> 컴파일 단계에서 추가적인 시간 필요하지만 더 빠르게 실행

- JS 엔진 : 크롬 V8, 파폭 SpiderMonkey, 사파리 JSCore, 마이크로소프트 엣지 Chakra
- JS 엔진이 하는 일 : JS 를 해석하고 실행시킴 : 어디에 있나? 브라우저 & Node.js
- (용도 비교)
- 브라우저 : HTML, CSS, JS를 해석/실행해 웹페이지를 브라우저 화면에 "렌더링" 하는 것
- Node.js : 브라우저 외부에서 JS 실행환경 제공
- 그래서 둘다 ECMAScript를 실행 가능하지만 각각의 추가 기능은 호환되지 않는다.
- 브라우저에는 DOM API (파싱된 HTML 요소 선택 + 조작 기능의 집합) 제공, Node.js는 제공하지 않아 DOM 라이브러리를 사용해서 기능~ / 브라우저에는 Web API 도 있음
- Node.js 에서는 파일을 생성, 수정할 수 있는 파일시스템을 제공, 브라우저는 지원안함 (보안상의 이유)
- (요약)
- 브라우저 -> ECMAScript + DOM, BOM, Canvas, XMLHttpRequest, fetch, requestAnnimation Frame, SVG, Web Storage, Web Component, Web Worker 같은 클라이언트 사이드 Web API를 지원
- Node.js -> ECMAScript + Node.js Host API 지원
