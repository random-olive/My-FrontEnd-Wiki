# JavaScript



0. ECMAScript란?
- 자바스크립트 표준 사양이며, 핵심문법을 규정함
- 각 브라우저 제조사는 사양을 준수하여 JS 엔진을 구현해야 함
- JavaScript = ECMAScript + 지원 API 를 포괄


1. JavaScript란?
- 프로토타입 기반으로 객체지향 프로그래밍을 지원하는 프로그래밍 언어
- HTML, CSS와 함께 웹을 구성하는 요소
- 브라우저에서 동작하는 유일한 언어 + 인터프리터 언어


2. ES5, ES6 의 가장 큰 차이?
- const/let, 화살표 함수, 템플릿 리터럴, Promise, Class, Rest, Spread, 모듈, 구조분해 할당 등의 도입


3. SPA (Single Page Application)
- 페이지 전체를 로딩한 후, 일부 영역의 데이터만 변경하여 사용할 수 있는 애플리케이션 (CSR방식)
- 사용자 인터렉션이 많아지던 환경과 Ajax의 등장으로 등장하게 되었다.


4. Ajax (Asynchronous Javascript And XML)
- JS를 이용해 서버와 브라우저가 비동기 방식으로 데이터를 교환할 수 있는 통신 기능
- 브라우저가 제공하는 Web API인 XMLHttpRequest 객체를 기반으로 동작

    - XMLHttpRequest : HTTP 비동기 통신을 위한 메서드, 프로퍼티 제공



5. SSR & CSR (Server Side Rendering & Client Side Rendering)

- SSR : 서버에서 렌더링(화면 구성) 후 전달 -> 브라우저는 렌더링 준비가 된 HTML 파일을 받음
- 장점 : SEO 가능, 초기 로딩속도 빠름
- 단점 : 페이지 이동시마다 전체 렌더링 -> 깜빡거림, 서버 트래픽 부담

- CSR : 서버에서 빈 페이지(HTML, CSS)를 최초 렌더링 후 JS링크와 함께 전달, 사용자가 요청시마다 클라이언트내 브라우저에서 JS로 렌더링
- 장점 : 필요한 데이터만 받아서 그림 -> 트래픽 감소, 새로고침 x
- 단점 : 초기 로딩속도 느림, 많은 크롤러들이 JS를 지원하지 않을 경우 SEO가 잘 되지 않음


6. JavaScript 엔진
- JS를 해석하고 실행시킨다. 브라우저와 Node.js 등에 있다. 싱글 스레드로 동작 (단 하나의 실행 컨텍스트 스택을 가짐)
- 한 번에 하나의 task만 실행해서 시간이 걸리는 task 실행시 blocking 발생

- 구성
    1. call stack (실행 컨택스트 스택) : heap에 저장된 객체를 참조함
    2. heap : 객체가 저장되는 메모리 공간

- 구동 방식
    - task가 요청되면 call stack을 통해 작업을 실행
    - call stack에서는 소스코드의 평가와 실행을 하고, 나머지 처리는 엔진 구동 환경에서 담당한다.
    - 브라우저 환경은 task queue와 event loop를 제공한다.

- 종류 : 크롬 -V8, MS엣지 -Chakra, 사파리- JSCore, 파폭 -SpiderMonkey


7. Node.js

- V8 엔진 기반으로 빌드된 JS 런타임 환경. JS를 브라우저 아닌 환경에서도 동작할 수 있도록 엔진을 브라우저에서 독립시킴
- 용도 : (주로) 서버사이드 애플리케이션 개발
- 특징 : 싱글 스레드 이벤트 루프 기반 동작, 비동기 입출력 지원 -> SPA에 적합, 내장 API 지원
- 의의 : Node.js의 등장으로 JS는 프론트엔드 영역은 물론 백엔드 영역까지 커버 -> 기능의 확장성

- npm (node package manager): Node.js에서 사용할 수 있는 모듈들을 패키지화하여 모아둔 저장소, 설치, 관리를 위한 CLI 제공 


8. 컴파일 타임 & 런타임

- 컴파일 타임 : 작성한 언어를 다른 언어로 변환하는 과정
- 런타임 : 프로그래밍 언어가 구동되는 환경
- 비교 :
  - 컴파일 에러 : syntax, reference, type check 등 -> 문제 라인을 알려줌
  - 런타임 에러 : 0나누기, Null 참조, 메모리 부족 및 프로그램 실행 중 발생하는 예상치 못한 오류 또는 충돌
  - 컴파일 언어는 컴파일 & 실행 단계가 분리, 인터프리터 언어는 한 statement씩 해석-실행 반복


9. 변수와 상수

- 변수 : 값을 저장하기 위해 확보된 메모리 공간 자체
- 상수 : 재할당이 금지된 변수
- JavaScript에서 변수, 함수를 사용하는 이유? : 재사용하기 위해서


10. 변수, 호이스팅, TDZ(Temporal Dead Zone)

- 변수 : 선언, 초기화 (메모리 할당), 할당 단계를 가짐 (렉시컬 환경의 작동 방식에 따라)

  - var : 재선언, 재할당 가능, 함수 스코프(전역), 선언 + 초기화 => 호이스팅시 초기화가 되어서 참조 에러 발생하지 않음, undefined 반환
  - let : 재할당만 가능, 블록 스코프, 선언 / 초기화 => 호이스팅시 초기화가 되지 않아 (TDZ) 참조 에러 발생
  - const : 모두 불가, 블록 스코프, 선언 / 초기화 => 호이스팅시 초기화가 되지 않아 (TDZ) 참조 에러 발생

- TDZ (Temporal Dead Zone) : 선언 단계는 호이스팅에 의해 먼저 실행되지만, 초기화 단계는 변수 선언문에 도달했을 때 실행된다.
  즉, let, const 는 스코프의 시작 ~ 초기화 시작 시점까지 해당 변수를 참조할 수 없는데, 이 구간을 일시적 사각지대라고 한다.

- 호이스팅 : 변수 선언문이 스코프의 선두로 끌어 올려진 것처럼 동작하는 JS 고유의 특징. 선언이 어디있든지 참조 가능

  - TDZ 발생 : let, const, class, super, 기본 매개변수
  - 이상 x : var, 함수 선언식(function), import

- WHY? "JS 엔진"은 소스코드 평가 과정에서 모든 선언문을 먼저 찾아내서 실행

- 전역 변수 : 생명주기 life cycle 가 애플리케이션의 생명주기와 같아서 메모리 리소스도 오랜동안 소비한다.
  또한, 코드의 가독성 저하, 의도치 않은 상태 변경 가능성, 스코프 체인 상 종점에 있어서 검색 속도가 가장 느리다는 점, 파일 분리가 되어 있어도 네임 스페이스 오염 가능성이 크다는 문제점 등을 가지고 있다.

- 지역 변수 : 생명주기가 함수의 생명주기와 대부분 일치한다.


12. 식별자 identifier 와 스코프 scope

- 식별자 : 코드 내의 변수, 함수, 클래스, 속성 등을 식별하는 문자열. 문자열(데이터)과 식별자(코드)는 다르다.
- 식별자 검색 resolution : "JS 엔진"이 스코프 체인을 통해 렉시컬 환경에서 참조할 변수를 검색/결정하는 것 (지역->전역)
  이를 통해 상위에서 선언한 것은 하위에서도 참조 가능하지만 반대는 불가

- 스코프 : 식별자가 유효한 범위. 식별자가 선언된 위치에 의해 결정된다(렉시컬 스코프). 이름이 존재하는 공간(namespace)
- 스코프 개념이 없다면? : 스코프 내에서 식별자는 유일해야 하므로 같은 이름의 변수의 경우 충돌한다.

- 전역 : 코드의 가장 바깥 영역
- 지역 : 함수 코드블럭 내부

- 전역 스코프 : 전역에 변수를 선언하면 전역 스코프를 갖는 변수가 된다. 어디서든 참조 가능하다.
- 지역 스코프 : 함수 몸체 내부에서 만든 스코프. 자신의 지역과 하위 지역 스코프에서만 유효하며, 모든 지역 스코프의 최상위는 전역 스코프

- 렉시컬 환경 : 실행할 스코프 범위 안에 있는 변수, 함수를 프로퍼티로 저장하는 객체. 코드 block, function, script를 실행하기 앞서 생성됨
- 스코프 체인 : 식별자 검색을 위한 매커니즘. 모든 스코프는 하나의 계층적 구조로 연결되는데, 이렇게 연결된 것을 스코프 체인이라 한다.
- 스코프 체이닝 : 식별자 검색을 할 때, 중복되는 변수가 있더라도 먼저 탐색된 변수를 우선적으로 실행시킴
- 매커니즘 : "JS 엔진"은 코드 실행 전 렉시컬 환경을 실제로 생성한 후, 실행 컨텍스트의 렉시컬 환경을 단방향으로 연결해서 스코프 체인을 물리적으로 생성한다. 전역 렉시컬 환경은 코드가 로드되면 곧바로 생성되고, 함수의 렉시컬 환경은 함수가 호출되면 바로 생성된다.

- 동적 스코프 : 함수 호출 시점에 동적으로 상위 스코프 결정
- 정적 스코프 (렉시컬 스코프) : 함수 정의 위치에 따라 정적으로 상위스코프 결정 => JavaScript
  함수가 호출될 때마다 함수의 상위 스코프를 참조
  함수 선언문으로 정의된 함수는 소스코드 평가과정에서 먼저 평가되어 함수객체를 생성하고, 상위 스코프를 기억한다.


13. 실행 컨텍스트 (execution context)

- 소스 코드를 실행하기 위한 필요한 것(변수 상태 등)들을 관리하는 내부 매커니즘. 상위 스코프의 렉시컬 환경을 관리한다.
- JS 동작 원리를 담고 있는 핵심 개념. 스코프, 호이스팅, 클로저, task queue, 이벤트 핸들러, 비동기 처리 동작 방식 등을 담당




14. 가비지 콜렉터란?

- 애플리케이션이 메모리 공간을 주기적으로 검사하여 더이상 사용하지 않는 메모리를 해제하는 기능 -> 메모리 누수 방지
- JavaScript : 가비지 콜렉터를 내장하고 있는 Managed 언어, Mark-and-sweep 알고리즘을 사용하고 있다.
  1. 가비지 콜렉터가 루트 (매개변수, 전역변수 등 태생부터 도달가능한 값들) 를 획득하여 그들을 마크
  2. 모든 루트와 자식-후손-.. 계속 타고 검사해서 도달 가능성 (스코프) 판단 & 활성상태 마크
  3. 마지막으로 활성표시 아닌 메모리를 OS에 반환


15. 예약어 : 프로그래밍 언어에서 사용되고 있거나 예정이어서 변수, 함수 이름으로 사용 불가능한 단어 (for, if, in, ...)


16. JavaScript 네이밍 컨벤션

- 변수, 함수 이름 : camelCase
- 클래스, 생성자 함수 이름 : PascalCase
- 상수 : SNAKE_CASE


17. JavaScript 데이터 타입 (7개의 자료형)

- 종류

  1. primitive type -> each type
     - number, string, boolean, symbol, undefined, null
  2. reference type -> object
     - function, array, object

- Symbol : 변경 불가능한 unique한 값

- JavaScript의 number : 다른 언어와의 차이점 : 모든 수를 float number 실수로 처리

- undefined & null의 차이점

  - undefined : "JS 엔진"이 변수를 초기화할 때 사용하는 값, 개발자가 의도적으로 할당하는 것이 아님
  - null : 변수에 값이 비어 있음 / 할당되어 있던 값의 참조 제거를 명시할 때 의도적으로 할당 (의도적 부재)

- 데이터 타입이 필요한 이유
  - 값을 저장 / 참조할 때 사용해야 하는 메모리 공간의 크기를 결정하기 위해
  - 메모리에서 읽어들인 2진수를 어떻게 해석할지 결정하기 위해


18. 타입

    1. 타입 변환

       - 명시적 (타입 캐스팅) : 빌트인 생성자 함수, 메서드 등을 사용해서 개발자가 의도적으로 값의 타입을 변환
       - 암묵적 (타입 강제변환) : 표현식을 평가하는 도중에 "JS 엔진"에 의해 암묵적으로 변환 (개발자 의도 x),
         평가를 위해 일시적으로 생성된 변수는 평가가 끝나면 가비지 컬렉터에 의해 삭제됨

    2. 단축 평가 : 표현식을 평가하는 도중 평가 결과가 확정된 경우, 나머지 평가과정을 생략 (ex) true && anything // anything

    3. false 로 평가되는 Falsy 값 : false, undefined, null, 0, -0, NaN, ''

    4. 정적 타입언어 vs 동적 타입언어

       - 정적 타입 언어 (C, Java) : 선언 단계에서 타입 결정. 타입에 맞는 값만 할당 가능, 타입 변경 불가
       - 동적 타입 언어 (JavaScript) : 선언이 아닌, 할당 단계에 의해 타입 결정. 재할당에 의해 변수 타입 변경 가능
       - 정적 타입 언어는 타입 체크를 통과하지 않으면 컴파일 에러 -> 런타임 에러 감소 (안정적 코드)

    5. 동등비교(==) vs 일치비교(===)
       - == : 암묵적으로 타입 변환을 통해 타입을 일치시킨 후에 비교 판단
       - === : 타입이 같고, 값이 같아야 true 반환
       - == 는 예측하기 어려운 결과를 낸다 -> === 연산자 권장


19. 원시 타입 vs 참조 타입

- primitive : immutable value -> call by value
- reference : mutable value -> call by reference

- call by : 변수에 해당 타입의 변수를 할당했을 때 어떤 값이 전달되는가

  - call by value : 실제값이 전달된다. 두 개의 변수는 다른 메모리 공간에 저장된 별개의 값. 하지만 엄밀히는 메모리 주소값을 전달시키며,
    식별자에 의해 달리 접근하게 된다. 서로 영향 못 줌

  - call by reference : 참조 주소가 전달된다. 두 개의 변수는 다른 메모리 공간에 저장된 별개의 값. 메모리 주소값을 전달시키며,
    타입 특성상 여러개의 식별자가 하나의 객체를 공유하게 된다. 서로 영향 줌

  - call by reference 부작용 및 해결방법
    - 원인 : 객체가 변경 가능한 값으로 설계되었기 때문
    - 부작용 : 원본, 복사된 객체 중 어느 한 쪽에서 객체의 property 값을 변경, 삭제하면 서로 영향을 주고 받는다.
    - 해결 방법 : 객체를 불변 객체로 만들어 사용하고, 상태 변경시 객체를 deep copy해서 만든 객체로 재할당-교체한다.
      이로서 외부 상태가 변경되는 부수 효과를 없앨 수 있다.
    - 불변 객체 생성 방법 : const 로는 재할당을 방지하고, Object.freeze()로는 객체의 속성 변경을 방지한다.

- shallow copy : 원본,복사본-> 동일한 참조를 공유. 의도치 않게 변경될 수 있음 ~ call by reference
- deep copy : 원본,복사본-> 동일하지 않은 참조를 공유. : Object.assign(), 전개연산자 등으로 구현 ~ call by value


20. 객체 : 순서가 없는 자료구조이며, 상태 데이터(property) 와 처리 로직(method) 을 하나의 논리적인 단위로 묶음

- property : 객체의 상태를 나타내는 data. key : value pair
- method : 프로퍼티 값이 함수일 경우, 일반 함수와 구분하기 위해 method라고 불린다. 상태 데이터property 를 참조, 조작 가능하다.

- 분류

  - 표준 빌트인 객체 : ECMAScript 사양에 정의된 객체. 전역 객체의 프로퍼티로서 제공되며, 별도의 선언없이 언제나 참조 가능
    Object, String, Number, Boolean, ...
  - 호스트 객체 : ECMAScript 사양에 정의되지 않음. JS 실행 환경에서 추가적으로 제공하는 객체
    (browser) Web API DOM, BOM, Canvas, XMLHttpRequest, fetch, SVG, Web Storage
    (Node.js) Node.js API
  - wrapper 객체 : primitive 값을 객체처럼 사용하면 생성되는 임시 객체. 객체 메서드를 사용 후 다시 원시값으로 돌아옴
  - 전역 객체 : 코드가 실행되기 이전 단계에 "JS 엔진"에 의해 생성되는 특수한 객체 : (browser) window, (Node.js) global
    아래의 객체들을 프로퍼티로 가지게 되어 접근 가능하다.
    표준 빌트인 객체 + 호스트 객체 + var 키워드로 선언한 전역 변수와 함수, 암묵적 전역 (키워드 없이 변수 선언)

- 생성 방법 : 객체 리터럴, 클래스(ES6), Object 생성자 함수, 생성자 함수, Object.create() 메서드
- 특징 : 클래스 없이 객체 생성 + 동적으로 property, method 추가 가능 (클래스 기반 객체지향 프로그래밍 언어와 다름)

- 객체가 변경 가능한 값으로 설계된 이유 : primitive type과는 달리 메모리 크기가 일정하지 않아, 복사-생성 cost가 크다.
  결국 메모리 효율성을 위해 변경 가능한 값으로 설계되었지만, 이로 인해 여러 개의 식별자가 하나의 객체를 공유한다는 구조적인 단점을 갖고 있다.

- 유사 배열 객체 : 배열처럼 index로 property 값에 접근 가능하고, length property 를 갖는 객체. for 문으로 순회 가능
- 문자열 : 유사 배열 객체 & iterable -> 배열과 유사하게 각 문자에 접근 가능

- 일반 객체와 함수의 차이점 : 일반객체는 호출 불가, 함수는 호출 가능

- [object Object] : 파일에 객체 내용을 그대로 출력하면 나온다. 내용을 제대로 보려면 JSON.stringify() 를 사용해서 JSON 문자열로 변환해야함

- this : 자기 참조 변수. 현재 동작하고 있는 코드를 가지고 있는 객체를 가리킴 -> 객체 멤버의 context가 변경되어도 정확한 값을 사용하기 위함
- this 바인딩 : this가 가리키는 값. 함수 호출 방식에 따라 동적으로 결정된다.
  |함수 호출 방식|this 바인딩|
  |----------|----------|
  |일반 함수로서|전역 객체|
  |메서드로서|메서드를 호출한 객체|
  |생성자 함수로서|생성될 인스턴스|
  |Function.prototype.apply/call/bind 메서드에 의한 간접호출|... 메서드에 첫번째 인자로 전달한 객체|

* 일급 객체 first-class citizen : 값의 성질을 갖는 객체
  - 다음과 같이 '다른 객체들에 일반적으로 적용 가능한 연산'을 모두 지원함
    - 무명의 리터럴로 생성 가능 (런타임에 생성 가능)
    - 변수, 데이터 구조 안에 할당
    - 다른 함수에 전달 인자로 전달
    - 다른 함수의 결과로 리턴 가능


21. 함수 (일급 객체)

    1.  매개변수 parameter vs 인수, 인자 argument

        - 쓰임에 따라 구분된다
        - 매개변수 : 함수를 정의할 때 사용되는 변수
        - 인자 : 실제로 함수가 호출될 때 넘기는 변수값

    2.  표현 방법
        - 선언식 : function() ex{...} // 선언식은 호이스팅 영향 받음 (선언, 초기화, 할당이 한꺼번에 이뤄짐)
        - 표현식 : const ex = function() {...} // 표현식은 클로저, 콜백으로 사용 가능 (유용함)
        - 화살표 함수 : const ex = () => {...}  
          // 생성자 함수로 사용 불가, 함수 자체에 this, arguments, super 바인딩을 갖지 않는다. 해당을 참조하면 상위 스코프의 것을 참조

- 생성자 함수 constructor function & 인스턴스 instance

  - 생성자 함수 : new 연산자와 함께 객체를 생성하는 함수. 모든 생성자 함수는 constructor 속성을 지닌 객체를 프로토타입 객체로 갖고있다.
    constructor 속성은 생성자 함수 자신을 가리키고 있다.
  - 인스턴스 : 생성자 함수로부터 생성된 객체

- 재귀 함수 : 자기 자신을 호출. 탈출 조건이 없으면 stack overflow 발생
- 콜백 함수 : 다른 함수의 인자로 전달되는 함수
- 고차 함수 : 콜백함수를 인자로 전달받거나 함수를 리턴할 수 있는 함수 (ex) map, filter, reduce
- 커링 함수 : 함수를 리턴하는 함수
- 순수 함수 : 부수 효과가 없는 함수. 동일 인자 전달시 동일한 결과를 반환하며, 외부 상태에 의존하지 않고 외부 상태를 변경하지도 않는다.

- 관계도

  - 콜백함수 + 커링함수 ⊂ 고차함수 ⊂ 함수 (일급 객체)

- 클로저 (closure) : 외부 변수를 참조할 수 있는 함수. JS의 사실상 모든 함수가 클로저.
  클로저는 함수 + 그 함수가 선언된 렉시컬 환경의 조합
  상태를 안전하게 은닉하고 특정 함수에게만 상태 변경을 허용하기 위해 사용한다.

- 매커니즘 : 함수가 "생성될 때", [[Environment]]라는 내부 프로퍼티에 외부 렉시컬 환경에 대한 참조를 저장하게 된다. 그리고 해당 함수가 호출될 때, 그 함수에 대한 렉시컬 환경 객체가 생성되고, 이 객체가 외부 렉시컬 환경에 대한 참조를 프로퍼티로부터 가져온다. 체이닝하는 렉시컬 환경이 클로저를 가능하게 한다.

- 클래스 : 프로토타입 기반의 객체 생성 매커니즘을 제공하는 함수


- 함수형 프로그래밍 : 순수 함수를 통해 부수 효과를 최대한 억제해 안정성을 높인 프로그래밍 패러다임

- 고차함수가 권장되는 이유 : 추상화, 재사용성, 가독성, 불변성


22. 객체지향 프로그래밍 (Object Oriented Programming, OOP)

- 필요한 데이터를 추상화시켜 상태와 행위를 가진 객체를 만들고, 그 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법
- 기능을 가지고 있는 클래스를 인스턴스화 한 후, 필요한 기능을 각 인스턴스가 수행하게 하면 프로그램이 만들어짐
- 재사용성, 유지보수성 ...

  - 주요 개념
    - 캡슐화 encapsulation : 관련이 있는 멤버 변수-메서드를 클래스와 같은 하나의 틀 안에 담고
      외부에 공개될 필요가 없는 정보를 숨겨 상태 변경 방지해 정보를 보호하는 것. 정보 은닉 information hiding
    - 상속 inheritance : 어떤 객체의 프로퍼티 또는 메서드를 다른 객체가 상속받아 그대로 사용할 수 있는 것
    - 추상화 abstraction : 객체의 핵심적인 개념 또는 기능만을 추출. 로직을 별도로 구분
    - 다형성 polymorphism : 같은 코드가 다른 행위를 하는 것. 아래와 같이 구현한다.
      - Overriding : 상속받은 부모의 메서드를 재정의하는 것
      - Overloading : 하나의 클래스에서 같은 이름의 메서드들을 여러 개 가질 수 있게 한다. 다만, 인자는 달라야 한다. (java)
      - 다형성은 상속을 통한 기능을 확장, 코드를 개선해준다.


23. 프로토타입 (prototype) - 상속을 위한 템플릿

- 프로토타입 객체 : 모든 객체들이 가지는 내장 객체. 상속에 관한 것들은 객체의 생성자의 prototype(Object.prototype) 에 정의되어 있음
  하위 프로토타입 객체는 상위 프로토타입 객체로부터 프로퍼티를 상속받을 수 있다.
- 프로토타입의 생성 시점 : 생성자 함수가 생성되는 시점. 생성자 함수-prototype은 pair
- 프로토타입 체인 : 상속 & 프로퍼티 검색을 위한 매커니즘. 객체의 프로퍼티에 접근하려고 할 때, 해당 객체에 접근하려는 프로퍼티가 없다면
  내부 참조를 따라 상위 프로토타입의 프로퍼티를 순차적으로 검색한다. 프로퍼티가 아닌 식별자는 스코프 체인에서 검색한다.
- 속성은 생성자에서, 메서드는 프로토타입에서 정의/변경한다.
- 상속 방법 : 프로토타입끼리 연결해서, 부모 프로토타입을 create(), setPropertyOf() 메서드 등을 사용해서 자식 프로토타입과 연결
-> 속성을 사용 가능하다


24. 클래스

- 프로토타입 기반의 객체 생성 매커니즘을 제공하는 함수
- 프로토타입 기반 패턴을 클래스 기반 패턴처럼 사용할 수 있도록 하는 문법적 설탕 (동작은 기존과 동일하지만 구현에 맞춰 새로운 문법을 제공함)
- 데이터, 데이터를 조작하는 함수를 추상화한다.

- 클래스에는 필드(프로퍼티), constructor, 메서드를 정의 가능하다.
- 필드 : 클래스 내에서 다루고픈 프로퍼티 범위
- 생성자 함수 : 객체 생성, 초기화 메서드
- 메서드 : constructor, 프로토타입 메서드, 정적 메서드

- prefixes : this(public), #(private), static, _(protected?)

- 비교
  - private vs static : private는 캡슐화를 위해 사용, static은 값의 연산의 공유를 위해 사용
  - 정적 메서드 vs 프로토타입 메서드 : 정적 메서드는 클래스로 호출되고, 프로토타입 메서드는 인스턴스로 호출됨 / 속한 프로토타입 체인 다름


25. 상속
- extends 키워드로 클래스를 상속할 수 있다. 
- 상속을 통해 확장된 클래스는 서브클래스, 파생클래스, 자식 클래스로 불리며, 반대는 수퍼블래스, 베이스 클래스, 부모 클래스로 불린다.

- 서브클래스는 super를 반드시 호출해야 하는데, 인스턴스 생성을 수퍼클래스에게 위임하기 때문이다. 
- super 키워드로 수퍼클래스의 constructor나 method를 호출할 수 있다.


26. Rest 파라미터 : 매개변수 앞에 ...를 붙여 정의 -> 배열로 전달


27. 배열 : 순서가 있는 자료구조
- 요소 : 배열이 가지고 있는 값
- 배열 생성 방법 : 배열 리터럴, Array 생성자 함수, Array.of, Array.from
- 객체와의 차이 : 가장 큰 차이는 순서, length 프로퍼티 여부
|구분|객체|배열|
|---|---|---|
|구조|프로퍼티 키:값|인덱스,요소|
|값의 참조|키|인덱스|
|값의 순서|X|O|
|length 프로퍼티|X|O|

- 배열의 비교
    - 배열 (자료구조) -> dense array
        - 요소는 하나의 데이터 타입으로 통일, 서로 연속적으로 인접
        - 인덱스를 통해 한 번의 연산으로 random access 가능 -> 고속 동작, 효율적
    - 배열 (JS) -> sparse array
        - 메모리 공간이 동일하지 않아도 되고, 연속적 인접을 안해도 됨
        - 해시테이블로 구현된, 일반적인 배열의 동작을 흉내낸 특수한 "객체"
        - 위의 배열보다는 속도가 느리지만, 특정 요소 삽입, 삭제시 위의 배열보다 빠른 성능을 가진다.

- 메서드 종류
    - mutator : 원본 변경 : push, unshift, splice, join, reverse, fill, sort 
    - accessor : 원본 불변 : concat, slice, map, filter, reduce


28. 자료구조
- 비선형 : 하나의 자료 뒤에 여러 개의 자료가 존재할 수 있음
    - 트리(1개의 루트), 그래프(루트x)
- 선형 : 하나의 자료 뒤에 하나의 자료만 존재
    - 배열, Stack(FILO), Queue(FIFO), linked list, hash table, ...


29. (rest 파라미터 & spread 문법) & 구조분해 할당 (ES6)
- ...을 써서 배열형의 자료구조를 묶거나 풀 때 씀
- 이터러블 구조를 파괴하여 1개 이상의 변수에 개별적으로 할당


30. Set & Map
- Set : 중복x, 유일한 값들의 집합  => new Set( [1,1,2] ) //{1,2}
- Map : 중복x, 키:값 pair 로 이뤄진 집합  => new Map([ ['key','value'] ]) //{'key'=>'value'}


31. DOM (Document Object Model, DOM 트리)
- HTML 문서를 파싱한 결과물. "노드 객체"들로 구성된 트리 자료구조를 가짐
- 문서의 계층적 구조, 정보를 표현하며 API(프로퍼티, 메서드)를 통해 HTML 구조, 내용, 스타일을 동적으로 조작 가능

- 생성 과정
    1. 브라우저가 서버로부터 HTML 문서를 바이트 (2진수) 형태로 받음
    2. <meta> charset 속성에 지정된 인코딩 방식 (UTF-8) 기준으로 문자열로 변환
    3. 문자열 -> 토큰(문법적 의미를 갖는 코드의 최소 단위)으로 분해
    4. 토큰 -> 객체로 변환 -> 노드 node 생성
    5. HTML 요소 간의 계층관계를 반영하여 모든 노드들을 트리 자료구조로 구성


32. 브라우저
- 렌더링 : HTML, CSS, JS 파일을 해석해서 브라우저 화면에 출력하는 과정
- 파싱 syntax analysis : 텍스트 문서를 읽어들여 실행하기 위해 문자열을 토큰으로 분해하고, 토큰에 문법적 의미와 구조를 반영하여
                        parse tree 자료구조 (AST, abstract syntax tree)를 생성하는 과정
                        이 트리를 기반으로 중간 언어인 바이트코드를 생성하고 실행한다.

- 브라우저 렌더링 과정
    - 브라우저가 리소스를 요청한 후 서버로부터 응답 받는다 (HTML, CSS, JS, 이미지, 폰트 파일 등)
    - 브라우저의 렌더링 엔진이 해당 자료들을 받아 DOM, CSSOM 생성 -> 렌더트리 생성

    - 브라우저의 "JS 엔진"이 JS를 파싱해서 AST를 생성
    - AST를 기반으로 바이트코드를 생성해서 인터프리터가 바이트코드를 실행하고,
    - JS는 DOM API를 통해 DOM, CSSOM을 변경할 수 있다.

    - 렌더트리 기반으로 HTML 요소의 레이아웃 변화를 계산하고 페인팅한다. (리플로우, 리페인팅)
    - 리렌더링은 노드 변경시, 브라우저 리사이징시, 스타일 변경시 나타나는데 성능에 악영향을 주니 빈번하게 발생하지 않도록 주의
    - transform: translate3d(x, y, z) : 
      GPU 가속을 사용해 GPU 메모리에서 관련 작업을 진행한다. 따라서 매우 빠르다. 따라서 관련 작업의 레이아웃, 페인트 작업이 없어지게 된다. 반복적인 레이아웃, 페인트 단계가 없어지므로 성능이 좋다.

- 브라우저는 동기적으로(순차적으로) HTML, CSS를 파싱하고 실행하는데 JS 파일이 먼저 파싱시, HTML 파싱(DOM 생성) 이 중단된다.
- 이를 방지하기 위해 HTML5부터 script 태그에 async, defer attribute가 추가됨. 둘다 HTML 렌더링할 때 JS 다운받는데
- async는 JS 다운로드가 끝나면 JS 실행
- defer는 HTML렌더링이 끝난 후 JS 실행
- 해당 attribute를 사용하면 HTML 파싱과 외부 JS 파일의 '로드'가 비동기적으로 동시에 실행된다.

- JS 엔진과는 달리 브라우저는 다음을 제공하며, 멀티 스레드로 동작한다.
    - micro task queue : 프로미스의 후속처리 메서드의 콜백이 일시적으로 보관되는 영역. task queue보다 우선순위가 높다.
    - task queue : 비동기 함수의 콜백이 일시적으로 보관되는 영역 
    - event loop : call stack 에 실행 중인 실행 컨텍스트가 있는지 / task queue에 대기중인 콜백이 있는지 반복해서 체크
                   call stack이 비어있고, task queue에 콜백이 있다면, FIFO로 콜백을 queue에서 stack으로 이동시킴
                   하지만 task queue보다 micro task queue 에 대기하고 있는 함수를 먼저 가져와 실행한다.


- MIME 타입(Multipurpose Internet Mail Extensions) : 브라우저가 리소스를 받았을 때의 기본 동작을 결정하기 위해 MIME 타입을 사용


33. HTML
- textContent: 마크업을 무시하고 텍스트만 반환 
- innerHTML: 마크업이 포함된 문자열을 그대로 반환 (장점은 조작이 간단하다는거지만, 단점은 XSS 공격에 취약하다는 점)

- 요소 노드는 초기상태와 최신상태를 관리해야 하는데,
- HTML attribute node : 요소 노드의 초기 상태를 관리
- DOM property : 요소 노드의 최신 상태를 관리


34. 이벤트
- 이벤트 핸들러 : 이벤트가 발생했을 때 호출될 함수
- 이벤트 핸들러 등록 : 이벤ㅅ트 발생시 브라우저에게 핸들러 호출을 위임
    - addEventListener, remove... 메서드 등으로 구현

- 이벤트 객체 : 이벤트가 발생하면 이벤트에 관련한 정보를 담고 있는 이벤트 객체가 동적으로 생성됨
- 이벤트 전파 propagation : DOM트리 상에 존재하는 DOM요소 노드에서 발생한 이벤트 객체는 이벤트 타겟을 중심으로 DOM 트리를 통해 전파된다.
    - 전파의 3단계 (전파 방향에 따라)
        1. 캡쳐링 단계 : 상위 요소 -> 하위 요소로 전파
        2. 타깃 단계 : 이벤트가 타깃에 도달
        3. 버블링 단계 : 하위 -> 상위 요소로 전파

- 이벤트 위임 delegation : 여러 개의 하위 DOM 요소에 각 이벤트 핸들러를 등록하지 않고 하나의 상위 DOM 요소에 이벤트 핸들러 등록

- preventDefault : DOM 요소의 기본 동작을 중단시킨다 (주로 a, submit(새로고침), button 등 특수한 기능을 의도치 않게 쓰는 것을 막기 위해)
- stopPropagation : 이벤트 전파를 중지시킬 때 사용 (주로 의도치 않은 캡쳐링, 버블링 단계 )

- scroll, resize, input, mousemove 같은 이벤트를 짧은 간격으로 '연속적으로' 발생 -> 과도한 호출 -> 성능 저하
- 이를 방지하기 위해 짧은 시간 발생하는 이벤트를 아래와 같이 그룹화하는 프로그래밍 기법을 사용해서 해결한다.
    - 디바운스 : 이벤트 핸들러가 호출되지 않다가 일정시간이 경과한 후에 한번만 호출되도록 함
               디바운스 함수의 첫 번째 인수로 전달한 콜백은 호출되지 않다가, delay동안 input이 없으면 한 번만 호출
              (ex) resize 이벤트 처리, 버튼 중복 클릭 방지

    - 스로틀 : 연속 발생시 일정 시간 간격으로 최대 한 번만 호출되도록
             delay가 결과하기 전에 이벤트가 발생하면 아무것도 하지 않다가 delay 시간이 경과 후 이벤트가 발생하면 콜백 호출, 새로운 타이머 재설정
             즉, delay 시간 간격으로 콜백 호출
             (ex) scroll 이벤트, 무한 스크롤 UI 구현


35. 동기 synchronous vs 비동기 asynchronous
- 동기 : 현재 실행 중인 task가 종료할 때까지 다음에 실행될 task가 대기하는 방식 (순차대로 하나씩 처리)

- 비동기 : 현재 실행중인 task가 종료되지 않아도 다음 task를 바로 실행
    - 각자 blocking, 실행순서 보장 안됨 등의 단점이 있다.
    - JS 엔진과 엔진 환경이 협력하여 비동기 함수를 실행한다.
    (ex) 타이머 함수(setTimeout, setInterval), HTTP 요청, 이벤트 핸들러

- 비동기 함수의 후속처리 진행하는 방법 : 후속처리 로직 콜백을 해당 비동기 함수에 전달해야 함
- 비동기 함수의 처리 결과에 대한 후속처리는 외부에 반환하거나 상위 스코프의 변수에 할당할 수 없어, 비동기 함수 내부에서 수행해야 한다.

- 이렇게 후속 처리 콜백이 비동기 결과를 반환하는 콜백이라면 콜백들이 중첩되어 복잡도가 높아지는 현상 (콜백 헬)이 발생한다. 
- 콜백 헬은 가독성이 나쁜 데다가 콜백 내부 에러가 catch 블록에서 제대로 캐치되지 않아 에러 처리가 어렵다.

- 프로미스 Promise : 콜백 헬을 극복하기 위해 도입. 비동기 처리의 상태, 결과를 관리하는 표준 빌트인 객체
    - 상태변경 조건 및 상태정보 : pending, settled (fullfilled -> resolve 결과 반환, rejected -> reject 결과 반환)
    - 콜백 헬을 해결하는 방법 : 후속 처리 메서드와 프로미스 체이닝을 통해 해결한다 (then, catch, finally)
    - 비동기 함수 + Promise -> (후속처리 메서드 -> 프로미스 반환) -> ( ) 체이닝...
    - 프로미스도 콜백을 사용하기 때문에 길어지면 가독성 문제가 다시 발생

- Promise.all() 메서드 : 여러 개의 비동기 처리를 모두 동시에 처리 : 모든 결과가 fullfilled 되면 배열에 담아 프로미스 반환

- 제너레이터 : 코드블록의 실행을 일시 중지했다가 필요 시점에 재개할 수 있는 함수
    1. 함수 제어권을 함수 호출자에게 양도 yield 가능
    2. 함수 호출자에게 상태를 전달하거나 받을 수 있다
    3. 제너레이터 함수를 호출하면 함수 코드를 실행하는 것이 아니라 제너레이터 객체를 반환한다.

    - 제너레이터 함수는 next 메서드와 yield 표현식을 통해 함수 호출자와 함수의 상태를 주고받을수 있다.
      이 특성을 이용하여 프로미스를 사용한 비동기 처리를 동기 처리처럼 구현 가능 (프로미스 후속 처리 메서드 없이 결과 반환)

- async / await : "후속처리 메서드" 없이 동기 처리처럼 프로미스 결과를 반환하도록 (ES8)
    - 언제나 프로미스를 반환하며, 프로미스를 기반으로 동작
    - await는 대기하다가 settled 상태가 되면 resolve 결과를 반환한다.
    - try...catch문을 사용 가능 (프로미스를 반환하기 때문에 호출자가 명확해서)


37. 네트워크
- URI : scheme + domain + port + path + query ...
  URL : query 이후 제외

- 서버에 요청하는 방법
    - 브라우저 주소 창 : 주소창에 URL 입력 (호스트이름) -> DNS -> IP -> IP주소의 서버에게 요청 전송
    - JS 를 통해 동적 요청
    - <form>, <a> 태그를 통해 전송

- HTTP(HyperText Transfer Protocol) : 브라우저 - 서버가 통신하기 위한 프로토콜
- JSON(JavaScript Object Notation) : 클라이언트 - 서버 HTTP 통신을 위한 text data format
- REST(REpresentational State Transfer) : HTTP 기반으로 클라이언트가 서버의 리소스에 '접근하는 방식'을 규정한 아키텍쳐
- REST API : REST를 기반으로 서비스 API를 구현한 것. REST의 기본원칙을 잘 지킨 서비스 디자인을 RESTful하다고 한다
    - 구성
        1. 자원 => URI(end point)
        2. 행위 => HTTP 요청 메서드
        3. 표현 => payload
    - 설계 원칙 
        - URI는 리소스를 표현하기 (명사)
        - 리소스에 대한 행위는 HTTP 요청 메서드로 표현

- 브라우저에서 URL을 치면 일어나는 과정
- 사용자가 웹 브라우저를 통해 google.com 을 입력하면 URL 주소 중 도메인 네임 부분을 DNS 서버에서 검색합니다.
- DNS 서버에서 해당 도메인 네임에 해당하는 IP 주소를 찾아 사용자가 입력한 URL 정보와 함께 전달합니다.
- 브라우저는 HTTP 프로토콜을 사용하여 요청 메시지를 생성하고 HTTP 요청 메시지는 TCP/IP 프로토콜을 사용하여 서버로 전송됩니다.
- 서버는 response 메시지를 생성하여 다시 브라우저에게 데이터를 전송합니다.
- 브라우저는 response를 받아 파싱하여 화면에 렌더링합니다.

1. 사용자가 웹 브라우저에 URL을 입력하기 시작, 브라우저의 캐시가 있다면 자동완성 기능 적용
2. 웹 브라우저가 URL 구문을 해석, URL 이 아니라면 브라우저의 기본 검색엔진으로 검색을 요청

3. URL 구문이 맞다면, TCP 연결을 만들기 위해 IP 주소가 필요하기 때문에 URL 에서 도메인명만 떼어내서 OS와 연동된 DNS resolver 에게 전달
4. DNS resolver 는 (네트워크 연결 설정 시 설정된, 또는 DHCP를 통해 자동으로 설정된) Local DNS 서버에게 해당 도메인명에 대한 IP 주소를 query함
5. query 를 받은 Local DNS 서버의 cache 에 해당 도메인명이 있다면 바로 응답을함(권한 없는 응답 = non-authoritative answer) 아니면 Root DNS 서버에 query 함
6. query 를 받은 Root DNS 서버의 cache 에 해당 도메인명이 있다면 바로 응답을함(권한 없는 응답 = non-authoritative answer) 아니면 자기가 알고있는 하위 DNS 서버(Root DNS 서버인 경우 TLD DNS 서버)의 정보를 Local DNS 서버에 회신
7. query 를 받은 TLD DNS 서버의 cache 에 해당 도메인명이 있다면 바로 응답을함(권한 없는 응답 = non-authoritative answer) 아니면 자기가 알고있는 하위 DNS 서버(TLD DNS 서버인 경우 SLD DNS 서버 또는 특정 회사의 authoritative DNS 서버)의 정보를 Local DNS 서버에 회신
8. query 를 받은 authoritative DNS 서버의 cache 에 해당 도메인명이 있다면 바로 응답을함(권한 있는 응답 = authoritative answer) 아니면 그런 도메인명이 없다고 응답함
9. Local DNS 서버는 도메인 서버에서 IP 정보를 획득하고 이를 클라이언트에 응답함

10. IP 정보를 얻은 클라이언트(웹 브라우저)는 해당 IP 를 활용해 TCP 연결을 설립(포트번호의 경우 일반적으로 well-known port number 를 사용하되, URL에 명시되어있는 경우 명시된 포트번호를 사용)
11. 만약 https 를 사용하는 URL 이었다면, 설립된 TCP 연결에 TLS 보안연결을 추가로 맺음
12. 설립된 TCP 연결 또는 TLS 연결에 HTTP request 메시지를 보냄. request header 에는 도메인명을 제외한 정보가 첫줄에 적혀있지만, HOST 헤더 속성에 도메인명도 기재하는 것이 보통임.
13. 클라이언트는 서버로부터 request 에 대한 response 를 수신하고, TCP 연결 또는 TLS 연결을 끊는다.
14. 클라이언트는 서버로 부터 응답받은 자원들을 처리한다.(렌더링, javascript 파싱 및 실행 등)

* 보통 PC는 DHCP 프로토콜로 IP 주소를 할당 받으면서 DNS 서버 IP 주소를 DHCP Option 6을 통해 함께 받습니다. (보통 2개의 DNS IP 주소를 받지요. Primary DNS 서버가 죽었을때 Secondary DNS 서버에 물어 보기 위해서. -> ipconfig /all 로 확인가능)

* DHCP는 Dynamic Host Configuration Protocol의 약자입니다. DHCP란 호스트의 IP주소와 각종 TCP/IP 프로토콜의 기본 설정을 클라이언트에게 자동적으로 제공해주는 프로토콜

* 권한있는 응답은 도메인에 대한 권한이 있으면 권한있는 응답이고, 권한없는 응답은 해당 도메인명이 있는 서버는 아니지만 (우연히) cache 에 도메인명 정보를 알아서 응답해주는걸 권한없는 응답이라고 한다.

* TLS(Transport Layer Security : 전송 계층 보안), 과거 명칭은 SSL(Secure Sockets Layer : 보안 소켓 레이어)로 암호 규약

- HTTP request 는 아래와 같은 흐름으로 진행된다..
- 송신측 : 계층을 거칠때마다 정보를 추가하면서 capsulation
- 수신측 : 정보를 삭제하면서 encapsulation

- Cookie, Local Storge, Session Storage



- XSS (cross site issue)

- 스레드 : 프로세스 내에서 실행되는 흐름의 단위





37. 기타
- 에러 처리가 필요한 이유 : 에러에 대해 대처하지 않으면 프로그램은 강제 종료됨
- 에러의 전파는 호출자 방향 (콜 스택의 아래 방향)으로 전파됨

- Function.prototype.apply/call/bind 메서드
    - apply, call 은 각각 함수를 호출하며, apply는 인자를 배열로 묶어 전달, call은 list로 전달,
      bind는 함수 호출하지 않고 this로 사용할 객체만 전달

- 모듈 : 재사용 가능한 코드 조각. 기능을 기준으로 분리, 캡슐화되어 다른 모듈에서 접근 불가 (유지보수성)
        자신만의 파일 스코프를 가진다. 즉, 모듈 내에서 var 키워드로 선언한 변수는 전역 변수가 아니며, window 객체의 프로퍼티도 아니다. 아직까지는 트랜스파일링이나 번들링이 필요하기 때문에 ES6 모듈 기능보다는 Webpack 등의 모듈 번들러를 사용하는 것이 일반적

- 결합도(모듈 간 상호 의존도)는 낮추고 응집도(모듈 내부 처리 요소들의 관련도)를 높게 모듈을 설계해 모듈의 독립성을 높이는 게 좋다.

- Babel과 Webpack
- Babel로 트랜스파일링할 때 CommonJS 방식의 require 함수는 Node.js가 기본 지원하는 시스템이어서 브라우저에서는 지원하지 않는다.
  때문에 브라우저에서 Babel만으로는 require 함수를 실행하지 못해, webpack이 필요하다.
- Webpack은 의존 관계에 있는 JS, CSS, ..등의 리소스들을 하나 이상의 파일로 번들링하는 모듈 번들러다.

- CSS Box Model : Content - padding - border - margin
---

# React

1. 라이브러리, 프레임워크 : React, Vue, Angular 를 사용하는 이유?

- 프로젝트 규모, 인터렉션에 따라 DOM 요소 변화가 증가, 그때마다 많은 렌더 트리 생성, 리플로우, 리페인트 과정을 거침
- 라이브러리, 프레임워크는 DOM 요소, 상태변화 관리를 최소화시켜 개발상 비효율을 줄인다.

2. React를 사용하는 이유 : 생산성, 유지보수성

- 찾아보기..

3. JSX (JavaScript + XML)

- JS 확장 구문. HTML과 문법이 유사하며, 리액트에서 HTML 요소를 표현할 때 사용. 빌드시 Babel에서 JS로 변환됨
- 


4. Virtual DOM

- 유저 인터렉션에 의해 상태변화가 일어나면 브라우저 작동 원리에 따라 렌더링 과정을 반복하는데, DOM이 순차적으로 변화를 받아들임과 달리 vDOM은 가상 모델에 우선 모든 변화를 적용한 최종 변화본을 DOM에 한번에 전달시켜 렌더링 비효율을 줄인다.

---

# CS

1. 프로그래밍 패러다임

- 명령형:절차적 (Imperative) vs "선언형" (Declarative)

  - 많은 선언적(WHAT) 접근의 방식들의 기반에는 일종의 명령적(HOW) 추상화가 존재한다.
  - 선언적 프로그래밍은 context-independent -> 유지보수, 불변성, 가독성, 코드 실행 추적 어려움

- 선언형 중 함수형 : 상태, 가변데이터를 멀리하는 프로그래밍 패러다임. 여기서 함수는 수학적 함수를 뜻함

  - 특징

    1. 순수 함수 사용
    2. 비상태성, 불변성 : 데이터 변경시 복사본을 생성 후 활용
    3. 선언형 함수 사용 : for -> map
    4. 일급 객체, 고차 함수 사용

  - 장점
    - 높은 수준의 추상화 & 재사용성, 불변성 -> 프로그램 동작 예측 쉬움
  - 단점
    - 가독성 좋지 않을 수 있다.
    - 반복이 for 문이 아니라 재귀 사용 -> 무한 루프 위험
    - 순수 함수 구현은 쉬울 수 있으나 조합은 쉽지 않을 수 있다.





- 프로세스 vs 스레드
    - 프로세스 : OS에서 할당한 작업의 단위. 코드 영역, 데이터 영역(변수, 데이터), 스택 영역, 힙 영역(동적 할당 데이터)
    - 스레드 : 프로세스 내에서 실행되는 흐름의 단위, 부모 프로세스의 스택을 제외한 나머지 자원을 공유한다
    - Node.js는 프로세스 실행히 여러 스레드를 생성하는데 직접 제어할 수 있는 스레드는 하나 뿐이어서 싱글 스레드로 여겨진다.
    - 멀티태스킹 : OS를 통해 CPU가 작업하는 자원을 프로세스/스레드 간에 나누는 행위



